{"ast":null,"code":"import * as d3 from \"d3\";\n\nclass Chart {\n  constructor() {\n    // Exposed variables\n    const attrs = {\n      id: `ID${Math.floor(Math.random() * 1000000)}`,\n      // Id for event handlings\n      svgWidth: 800,\n      svgHeight: 600,\n      marginTop: 0,\n      marginBottom: 0,\n      marginRight: 0,\n      marginLeft: 0,\n      container: 'body',\n      defaultTextFill: 'white',\n      nodeTextFill: 'white',\n      defaultFont: 'Helvetica',\n      backgroundColor: '#22518e',\n      data: null,\n      depth: 180,\n      duration: 600,\n      strokeWidth: 3,\n      dropShadowId: null,\n      initialZoom: 1,\n      onNodeClick: d => d\n    };\n\n    this.getChartState = () => attrs; // Dinamically set getter and setter functions for Chart class\n\n\n    Object.keys(attrs).forEach(key => {\n      //@ts-ignore\n      this[key] = function (_) {\n        var string = `attrs['${key}'] = _`;\n\n        if (!arguments.length) {\n          return eval(`attrs['${key}'];`);\n        }\n\n        eval(string);\n        return this;\n      };\n    });\n    this.initializeEnterExitUpdatePattern();\n  }\n\n  initializeEnterExitUpdatePattern() {\n    d3.selection.prototype.patternify = function (params) {\n      var container = this;\n      var selector = params.selector;\n      var elementTag = params.tag;\n      var data = params.data || [selector]; // Pattern in action\n\n      var selection = container.selectAll('.' + selector).data(data, (d, i) => {\n        if (typeof d === 'object') {\n          if (d.id) {\n            return d.id;\n          }\n        }\n\n        return i;\n      });\n      selection.exit().remove();\n      selection = selection.enter().append(elementTag).merge(selection);\n      selection.attr('class', selector);\n      return selection;\n    };\n  } // This method retrieves passed node's children ID's (including node)      \n\n\n  getNodeChildrenIds({\n    data,\n    children,\n    _children\n  }, nodeIdsStore) {\n    // Store current node ID\n    nodeIdsStore.push(data.nodeId); // Loop over children and recursively store descendants id (expanded nodes)\n\n    if (children) {\n      children.forEach(d => {\n        this.getNodeChildrenIds(d, nodeIdsStore);\n      });\n    } // Loop over _children and recursively store descendants id (collapsed nodes)\n\n\n    if (_children) {\n      _children.forEach(d => {\n        this.getNodeChildrenIds(d, nodeIdsStore);\n      });\n    } // Return result\n\n\n    return nodeIdsStore;\n  } // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale\n\n\n  setZoomFactor(zoomLevel) {\n    const attrs = this.getChartState();\n    const calc = attrs.calc; // Store passed zoom level\n\n    attrs.initialZoom = zoomLevel; // Rescale container element accordingly\n\n    attrs.centerG.attr('transform', ` translate(${calc.centerX}, ${calc.nodeMaxHeight / 2}) scale(${attrs.initialZoom})`);\n  }\n\n  render() {\n    //InnerFunctions which will update visuals\n    const attrs = this.getChartState();\n    const thisObjRef = this; //Drawing containers\n\n    const container = d3.select(attrs.container);\n    const containerRect = container.node().getBoundingClientRect();\n    if (containerRect.width > 0) attrs.svgWidth = containerRect.width; //Attach drop shadow id to attrs object\n\n    this.setDropShadowId(attrs); //Calculated properties\n\n    const calc = {\n      id: null,\n      chartTopMargin: null,\n      chartLeftMargin: null,\n      chartWidth: null,\n      chartHeight: null\n    };\n    calc.id = `ID${Math.floor(Math.random() * 1000000)}`; // id for event handlings\n\n    calc.chartLeftMargin = attrs.marginLeft;\n    calc.chartTopMargin = attrs.marginTop;\n    calc.chartWidth = attrs.svgWidth - attrs.marginRight - calc.chartLeftMargin;\n    calc.chartHeight = attrs.svgHeight - attrs.marginBottom - calc.chartTopMargin;\n    attrs.calc = calc; // Get maximum node width and height\n\n    calc.nodeMaxWidth = d3.max(attrs.data, ({\n      width\n    }) => width);\n    calc.nodeMaxHeight = d3.max(attrs.data, ({\n      height\n    }) => height); // Calculate max node depth (it's needed for layout heights calculation)\n\n    attrs.depth = calc.nodeMaxHeight + 100;\n    calc.centerX = calc.chartWidth / 2; //********************  LAYOUTS  ***********************\n\n    const layouts = {\n      treemap: null\n    };\n    attrs.layouts = layouts; // Generate tree layout function\n\n    layouts.treemap = d3.tree().size([calc.chartWidth, calc.chartHeight]).nodeSize([calc.nodeMaxWidth + 100, calc.nodeMaxHeight + attrs.depth]); // ******************* BEHAVIORS . **********************\n\n    const behaviors = {\n      zoom: null\n    }; // Get zooming function \n\n    behaviors.zoom = d3.zoom().on(\"zoom\", d => this.zoomed(d)); //****************** ROOT node work ************************\n    // Convert flat data to hierarchical\n\n    attrs.root = d3.stratify().id(({\n      nodeId\n    }) => nodeId).parentId(({\n      parentNodeId\n    }) => parentNodeId)(attrs.data); // Set child nodes enter appearance positions\n\n    attrs.root.x0 = 0;\n    attrs.root.y0 = 0;\n    /** Get all nodes as array (with extended parent & children properties set)\n        This way we can access any node's parent directly using node.parent - pretty cool, huh?\n    */\n\n    attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants(); // Assign direct children and total subordinate children's cound\n\n    attrs.allNodes.forEach(d => {\n      Object.assign(d.data, {\n        directSubordinates: d.children ? d.children.length : 0,\n        totalSubordinates: d.descendants().length - 1\n      });\n    }); // Collapse all children at first\n\n    attrs.root.children.forEach(d => this.collapse(d)); // Then expand some nodes, which have `expanded` property set\n\n    attrs.root.children.forEach(d => this.expandSomeNodes(d)); // *************************  DRAWING **************************\n    //Add svg\n\n    const svg = container.patternify({\n      tag: 'svg',\n      selector: 'svg-chart-container'\n    }).attr('width', \"100%\").attr('height', \"100vh\").attr('font-family', attrs.defaultFont).call(behaviors.zoom).attr('cursor', 'move').style('background-color', attrs.backgroundColor);\n    attrs.svg = svg; //Add container g element\n\n    const chart = svg.patternify({\n      tag: 'g',\n      selector: 'chart'\n    }).attr('transform', `translate(${calc.chartLeftMargin},${calc.chartTopMargin})`); // Add one more container g element, for better positioning controls\n\n    attrs.centerG = chart.patternify({\n      tag: 'g',\n      selector: 'center-group'\n    }).attr('transform', `translate(${calc.centerX},${calc.nodeMaxHeight / 2}) scale(${attrs.initialZoom})`);\n    attrs.chart = chart; // ************************** ROUNDED AND SHADOW IMAGE  WORK USING SVG FILTERS **********************\n    //Adding defs element for rounded image\n\n    attrs.defs = svg.patternify({\n      tag: 'defs',\n      selector: 'image-defs'\n    }); // Adding defs element for image's shadow\n\n    const filterDefs = svg.patternify({\n      tag: 'defs',\n      selector: 'filter-defs'\n    }); // Adding shadow element - (play with svg filter here - https://bit.ly/2HwnfyL)\n\n    const filter = filterDefs.patternify({\n      tag: 'filter',\n      selector: 'shadow-filter-element'\n    }).attr('id', attrs.dropShadowId).attr('y', `${-50}%`).attr('x', `${-50}%`).attr('height', `${200}%`).attr('width', `${200}%`); // Add gaussian blur element for shadows - we can control shadow length with this\n\n    filter.patternify({\n      tag: 'feGaussianBlur',\n      selector: 'feGaussianBlur-element'\n    }).attr('in', 'SourceAlpha').attr('stdDeviation', 3.1).attr('result', 'blur'); // Add fe-offset element for shadows -  we can control shadow positions with it\n\n    filter.patternify({\n      tag: 'feOffset',\n      selector: 'feOffset-element'\n    }).attr('in', 'blur').attr('result', 'offsetBlur').attr(\"dx\", 4.28).attr(\"dy\", 4.48).attr(\"x\", 8).attr(\"y\", 8); // Add fe-flood element for shadows - we can control shadow color and opacity with this element\n\n    filter.patternify({\n      tag: 'feFlood',\n      selector: 'feFlood-element'\n    }).attr(\"in\", \"offsetBlur\").attr(\"flood-color\", 'black').attr(\"flood-opacity\", 0.3).attr(\"result\", \"offsetColor\"); // Add feComposite element for shadows\n\n    filter.patternify({\n      tag: 'feComposite',\n      selector: 'feComposite-element'\n    }).attr(\"in\", \"offsetColor\").attr(\"in2\", \"offsetBlur\").attr(\"operator\", \"in\").attr(\"result\", \"offsetBlur\"); // Add feMerge element for shadows\n\n    const feMerge = filter.patternify({\n      tag: 'feMerge',\n      selector: 'feMerge-element'\n    }); // Add feMergeNode element for shadows\n\n    feMerge.patternify({\n      tag: 'feMergeNode',\n      selector: 'feMergeNode-blur'\n    }).attr('in', 'offsetBlur'); // Add another feMergeNode element for shadows\n\n    feMerge.patternify({\n      tag: 'feMergeNode',\n      selector: 'feMergeNode-graphic'\n    }).attr('in', 'SourceGraphic'); // Display tree contenrs\n\n    this.update(attrs.root); //#########################################  UTIL FUNCS ##################################\n    // This function restyles foreign object elements ()\n\n    d3.select(window).on(`resize.${attrs.id}`, () => {\n      const containerRect = container.node().getBoundingClientRect(); //  if (containerRect.width > 0) attrs.svgWidth = containerRect.width;\n      //\tmain();\n    });\n    return this;\n  } // This function sets drop shadow ID to the passed object\n\n\n  setDropShadowId(d) {\n    // If it's already set, then return \n    if (d.dropShadowId) return; // Generate drop shadow ID\n\n    let id = `${d.id}-drop-shadow`; // // If DOM object is available, then use UID method to generated shadow id\n    // //@ts-ignore\n    // if (typeof DOM != 'undefined') {\n    //     //@ts-ignore\n    //     id = DOM.uid(d.id).id;\n    // }\n    // Extend passed object with drop shadow ID\n\n    Object.assign(d, {\n      dropShadowId: id\n    });\n  } // This function can be invoked via chart.addNode API, and it adds node in tree at runtime\n\n\n  addNode(obj) {\n    const attrs = this.getChartState();\n    attrs.data.push(obj); // Update state of nodes and redraw graph\n\n    this.updateNodesState();\n    return this;\n  } // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime\n\n\n  removeNode(nodeId) {\n    const attrs = this.getChartState();\n    const node = attrs.allNodes.filter(({\n      data\n    }) => data.nodeId == nodeId)[0]; // Remove all node childs\n\n    if (node) {\n      // Retrieve all children nodes ids (including current node itself)\n      const nodeChildrenIds = this.getNodeChildrenIds(node, []); // Filter out retrieved nodes and reassign data\n\n      attrs.data = attrs.data.filter(d => !nodeChildrenIds.includes(d.nodeId));\n      const updateNodesState = this.updateNodesState.bind(this); // Update state of nodes and redraw graph\n\n      updateNodesState();\n    }\n  } // This function basically redraws visible graph, based on nodes state\n\n\n  update({\n    x0,\n    y0,\n    x,\n    y\n  }) {\n    const attrs = this.getChartState();\n    const calc = attrs.calc; //  Assigns the x and y position for the nodes\n\n    const treeData = attrs.layouts.treemap(attrs.root); // Get tree nodes and links and attach some properties \n\n    const nodes = treeData.descendants().map(d => {\n      // If at least one property is already set, then we don't want to reset other properties\n      if (d.width) return d; // Declare properties with deffault values\n\n      let imageWidth = 100;\n      let imageHeight = 100;\n      let imageBorderColor = 'steelblue';\n      let imageBorderWidth = 0;\n      let imageRx = 0;\n      let imageCenterTopDistance = 0;\n      let imageCenterLeftDistance = 0;\n      let borderColor = 'steelblue';\n      let backgroundColor = 'steelblue';\n      let width = d.data.width;\n      let height = d.data.height;\n      let dropShadowId = `none`; // Override default values based on data\n\n      if (d.data.nodeImage && d.data.nodeImage.shadow) {\n        dropShadowId = `url(#${attrs.dropShadowId})`;\n      }\n\n      if (d.data.nodeImage && d.data.nodeImage.width) {\n        imageWidth = d.data.nodeImage.width;\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.height) {\n        imageHeight = d.data.nodeImage.height;\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.borderColor) {\n        imageBorderColor = this.rgbaObjToColor(d.data.nodeImage.borderColor);\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.borderWidth) {\n        imageBorderWidth = d.data.nodeImage.borderWidth;\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.centerTopDistance) {\n        imageCenterTopDistance = d.data.nodeImage.centerTopDistance;\n      }\n\n      ;\n\n      if (d.data.nodeImage && d.data.nodeImage.centerLeftDistance) {\n        imageCenterLeftDistance = d.data.nodeImage.centerLeftDistance;\n      }\n\n      ;\n\n      if (d.data.borderColor) {\n        borderColor = this.rgbaObjToColor(d.data.borderColor);\n      }\n\n      if (d.data.backgroundColor) {\n        backgroundColor = this.rgbaObjToColor(d.data.backgroundColor);\n      }\n\n      if (d.data.nodeImage && d.data.nodeImage.cornerShape.toLowerCase() == \"circle\") {\n        imageRx = Math.max(imageWidth, imageHeight);\n      }\n\n      if (d.data.nodeImage && d.data.nodeImage.cornerShape.toLowerCase() == \"rounded\") {\n        imageRx = Math.min(imageWidth, imageHeight) / 6;\n      } // Extend node object with calculated properties\n\n\n      return Object.assign(d, {\n        imageWidth,\n        imageHeight,\n        imageBorderColor,\n        imageBorderWidth,\n        borderColor,\n        backgroundColor,\n        imageRx,\n        width,\n        height,\n        imageCenterTopDistance,\n        imageCenterLeftDistance,\n        dropShadowId\n      });\n    }); // Get all links\n\n    const links = treeData.descendants().slice(1); // Set constant depth for each nodes\n\n    nodes.forEach(d => d.y = d.depth * attrs.depth); // ------------------- FILTERS ---------------------\n    // Add patterns for each node (it's needed for rounded image implementation)\n\n    const patternsSelection = attrs.defs.selectAll('.pattern').data(nodes, ({\n      id\n    }) => id); // Define patterns enter selection\n\n    const patternEnterSelection = patternsSelection.enter().append('pattern'); // Patters update selection\n\n    const patterns = patternEnterSelection.merge(patternsSelection).attr('class', 'pattern').attr('height', 1).attr('width', 1).attr('id', ({\n      id\n    }) => id); // Add images to patterns\n\n    const patternImages = patterns.patternify({\n      tag: 'image',\n      selector: 'pattern-image',\n      data: d => [d]\n    }).attr('x', 0).attr('y', 0).attr('height', ({\n      imageWidth\n    }) => imageWidth).attr('width', ({\n      imageHeight\n    }) => imageHeight).attr('xlink:href', ({\n      data\n    }) => data.nodeImage.url).attr('viewbox', ({\n      imageWidth,\n      imageHeight\n    }) => `0 0 ${imageWidth * 2} ${imageHeight}`).attr('preserveAspectRatio', 'xMidYMin slice'); // Remove patterns exit selection after animation\n\n    patternsSelection.exit().transition().duration(attrs.duration).remove(); // --------------------------  LINKS ----------------------\n    // Get links selection\n\n    const linkSelection = attrs.centerG.selectAll('path.link').data(links, ({\n      id\n    }) => id); // Enter any new links at the parent's previous position.\n\n    const linkEnter = linkSelection.enter().insert('path', \"g\").attr(\"class\", \"link\").attr('d', d => {\n      const o = {\n        x: x0,\n        y: y0\n      };\n      return this.diagonal(o, o);\n    }); // Get links update selection\n\n    const linkUpdate = linkEnter.merge(linkSelection); // Styling links\n\n    linkUpdate.attr(\"fill\", \"none\").attr(\"stroke-width\", ({\n      data\n    }) => data.connectorLineWidth || 2).attr('stroke', ({\n      data\n    }) => {\n      if (data.connectorLineColor) {\n        return this.rgbaObjToColor(data.connectorLineColor);\n      }\n\n      return 'green';\n    }).attr('stroke-dasharray', ({\n      data\n    }) => {\n      if (data.dashArray) {\n        return data.dashArray;\n      }\n\n      return '';\n    }); // Transition back to the parent element position\n\n    linkUpdate.transition().duration(attrs.duration).attr('d', d => this.diagonal(d, d.parent)); // Remove any  links which is exiting after animation\n\n    const linkExit = linkSelection.exit().transition().duration(attrs.duration).attr('d', d => {\n      const o = {\n        x: x,\n        y: y\n      };\n      return this.diagonal(o, o);\n    }).remove(); // --------------------------  NODES ----------------------\n    // Get nodes selection\n\n    const nodesSelection = attrs.centerG.selectAll('g.node').data(nodes, ({\n      id\n    }) => id); // Enter any new nodes at the parent's previous position.\n\n    const nodeEnter = nodesSelection.enter().append('g').attr('class', 'node').attr(\"transform\", d => `translate(${x0},${y0})`).attr('cursor', 'pointer').on('click', ({\n      data\n    }) => {\n      if ([...d3.event.srcElement.classList].includes('node-button-circle')) {\n        return;\n      }\n\n      attrs.onNodeClick(data.nodeId);\n    }); // Add background rectangle for the nodes \n\n    nodeEnter.patternify({\n      tag: 'rect',\n      selector: 'node-rect',\n      data: d => [d]\n    }).style(\"fill\", ({\n      _children\n    }) => _children ? \"lightsteelblue\" : \"#fff\"); // Add node icon image inside node\n\n    nodeEnter.patternify({\n      tag: 'image',\n      selector: 'node-icon-image',\n      data: d => [d]\n    }).attr('width', ({\n      data\n    }) => data.nodeIcon.size).attr('height', ({\n      data\n    }) => data.nodeIcon.size).attr(\"xlink:href\", ({\n      data\n    }) => data.nodeIcon.icon).attr('x', ({\n      width\n    }) => -width / 2 + 5).attr('y', ({\n      height,\n      data\n    }) => height / 2 - data.nodeIcon.size - 5); // Add total descendants text\n\n    nodeEnter.patternify({\n      tag: 'text',\n      selector: 'node-icon-text-total',\n      data: d => [d]\n    }).text('test').attr('x', ({\n      width\n    }) => -width / 2 + 7).attr('y', ({\n      height,\n      data\n    }) => height / 2 - data.nodeIcon.size - 5).text(({\n      data\n    }) => `${data.totalSubordinates} Subordinates`).attr('fill', attrs.nodeTextFill).attr('font-weight', 'bold'); // Add direct descendants text\n\n    nodeEnter.patternify({\n      tag: 'text',\n      selector: 'node-icon-text-direct',\n      data: d => [d]\n    }).text('test').attr('x', ({\n      width,\n      data\n    }) => -width / 2 + 10 + data.nodeIcon.size).attr('y', ({\n      height\n    }) => height / 2 - 10).text(({\n      data\n    }) => `${data.directSubordinates} Direct `).attr('fill', attrs.nodeTextFill).attr('font-weight', 'bold'); // Defined node images wrapper group\n\n    const nodeImageGroups = nodeEnter.patternify({\n      tag: 'g',\n      selector: 'node-image-group',\n      data: d => [d]\n    }); // Add background rectangle for node image\n\n    nodeImageGroups.patternify({\n      tag: 'rect',\n      selector: 'node-image-rect',\n      data: d => [d]\n    }); // Node update styles\n\n    const nodeUpdate = nodeEnter.merge(nodesSelection).style('font', '12px sans-serif'); // Add foreignObject element inside rectangle\n\n    const fo = nodeUpdate.patternify({\n      tag: 'foreignObject',\n      selector: 'node-foreign-object',\n      data: d => [d]\n    }); // Add foreign object \n\n    fo.patternify({\n      tag: 'xhtml:div',\n      selector: 'node-foreign-object-div',\n      data: d => [d]\n    });\n    this.restyleForeignObjectElements(); // Add Node button circle's group (expand-collapse button)\n\n    const nodeButtonGroups = nodeEnter.patternify({\n      tag: 'g',\n      selector: 'node-button-g',\n      data: d => [d]\n    }).on('click', d => this.onButtonClick(d)); // Add expand collapse button circle \n\n    nodeButtonGroups.patternify({\n      tag: 'circle',\n      selector: 'node-button-circle',\n      data: d => [d]\n    }); // Add button text \n\n    nodeButtonGroups.patternify({\n      tag: 'text',\n      selector: 'node-button-text',\n      data: d => [d]\n    }).attr('pointer-events', 'none'); // Transition to the proper position for the node\n\n    nodeUpdate.transition().attr('opacity', 0).duration(attrs.duration).attr(\"transform\", ({\n      x,\n      y\n    }) => `translate(${x},${y})`).attr('opacity', 1); // Move images to desired positions\n\n    nodeUpdate.selectAll('.node-image-group').attr('transform', ({\n      imageWidth,\n      width,\n      imageHeight,\n      height\n    }) => {\n      let x = -imageWidth / 2 - width / 2;\n      let y = -imageHeight / 2 - height / 2;\n      return `translate(${x},${y})`;\n    }); // Style node image rectangles\n\n    nodeUpdate.select('.node-image-rect').attr('fill', ({\n      id\n    }) => `url(#${id})`).attr('width', ({\n      imageWidth\n    }) => imageWidth).attr('height', ({\n      imageHeight\n    }) => imageHeight).attr('stroke', ({\n      imageBorderColor\n    }) => imageBorderColor).attr('stroke-width', ({\n      imageBorderWidth\n    }) => imageBorderWidth).attr('rx', ({\n      imageRx\n    }) => imageRx).attr('y', ({\n      imageCenterTopDistance\n    }) => imageCenterTopDistance).attr('x', ({\n      imageCenterLeftDistance\n    }) => imageCenterLeftDistance).attr('filter', ({\n      dropShadowId\n    }) => dropShadowId); // Style node rectangles\n\n    nodeUpdate.select('.node-rect').attr('width', ({\n      data\n    }) => data.width).attr('height', ({\n      data\n    }) => data.height).attr('x', ({\n      data\n    }) => -data.width / 2).attr('y', ({\n      data\n    }) => -data.height / 2).attr('rx', ({\n      data\n    }) => data.borderRadius || 0).attr('stroke-width', ({\n      data\n    }) => data.borderWidth || attrs.strokeWidth).attr('cursor', 'pointer').attr('stroke', ({\n      borderColor\n    }) => borderColor).style(\"fill\", ({\n      backgroundColor\n    }) => backgroundColor); // Move node button group to the desired position\n\n    nodeUpdate.select('.node-button-g').attr('transform', ({\n      data\n    }) => `translate(0,${data.height / 2})`).attr('opacity', ({\n      children,\n      _children\n    }) => {\n      if (children || _children) {\n        return 1;\n      }\n\n      return 0;\n    }); // Restyle node button circle\n\n    nodeUpdate.select('.node-button-circle').attr('r', 20).attr('stroke-width', ({\n      data\n    }) => data.borderWidth || attrs.strokeWidth).attr('fill', attrs.backgroundColor).attr('stroke', ({\n      borderColor\n    }) => borderColor); // Restyle button texts\n\n    nodeUpdate.select('.node-button-text').attr('text-anchor', 'middle').attr('alignment-baseline', 'middle').attr('fill', attrs.defaultTextFill).attr('font-size', ({\n      children\n    }) => {\n      if (children) return 40;\n      return 30;\n    }).text(({\n      children\n    }) => {\n      if (children) return '-';\n      return '+';\n    }).attr('y', this.isEdge() ? 10 : 0); // Remove any exiting nodes after transition\n\n    const nodeExitTransition = nodesSelection.exit().attr('opacity', 1).transition().duration(attrs.duration).attr(\"transform\", d => `translate(${x},${y})`).on('end', function () {\n      d3.select(this).remove();\n    }).attr('opacity', 0); // On exit reduce the node rects size to 0\n\n    nodeExitTransition.selectAll('.node-rect').attr('width', 10).attr('height', 10).attr('x', 0).attr('y', 0); // On exit reduce the node image rects size to 0\n\n    nodeExitTransition.selectAll('.node-image-rect').attr('width', 10).attr('height', 10).attr('x', ({\n      width\n    }) => width / 2).attr('y', ({\n      height\n    }) => height / 2); // Store the old positions for transition.\n\n    nodes.forEach(d => {\n      d.x0 = d.x;\n      d.y0 = d.y;\n    });\n  } // This function detects whether current browser is edge\n\n\n  isEdge() {\n    return window.navigator.userAgent.includes(\"Edge\");\n  }\n  /* Function converts rgba objects to rgba color string \n    {red:110,green:150,blue:255,alpha:1}  => rgba(110,150,255,1)\n  */\n\n\n  rgbaObjToColor({\n    red,\n    green,\n    blue,\n    alpha\n  }) {\n    return `rgba(${red},${green},${blue},${alpha})`;\n  } // Generate custom diagonal - play with it here - https://to.ly/1zhTK\n\n\n  diagonal(s, t) {\n    // Calculate some variables based on source and target (s,t) coordinates\n    const x = s.x;\n    const y = s.y;\n    const ex = t.x;\n    const ey = t.y;\n    let xrvs = ex - x < 0 ? -1 : 1;\n    let yrvs = ey - y < 0 ? -1 : 1;\n    let rdef = 35;\n    let rInitial = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;\n    let r = Math.abs(ey - y) / 2 < rInitial ? Math.abs(ey - y) / 2 : rInitial;\n    let h = Math.abs(ey - y) / 2 - r;\n    let w = Math.abs(ex - x) - r * 2; // Build the path\n\n    const path = `\n               M ${x} ${y}\n               L ${x} ${y + h * yrvs}\n               C  ${x} ${y + h * yrvs + r * yrvs} ${x} ${y + h * yrvs + r * yrvs} ${x + r * xrvs} ${y + h * yrvs + r * yrvs}\n               L ${x + w * xrvs + r * xrvs} ${y + h * yrvs + r * yrvs}\n               C ${ex}  ${y + h * yrvs + r * yrvs} ${ex}  ${y + h * yrvs + r * yrvs} ${ex} ${ey - h * yrvs}\n               L ${ex} ${ey}\n             `; // Return result\n\n    return path;\n  }\n\n  restyleForeignObjectElements() {\n    const attrs = this.getChartState();\n    attrs.svg.selectAll('.node-foreign-object').attr('width', ({\n      width\n    }) => width).attr('height', ({\n      height\n    }) => height).attr('x', ({\n      width\n    }) => -width / 2).attr('y', ({\n      height\n    }) => -height / 2);\n    attrs.svg.selectAll('.node-foreign-object-div').style('width', ({\n      width\n    }) => `${width}px`).style('height', ({\n      height\n    }) => `${height}px`).style('color', 'white').html(({\n      data\n    }) => data.template);\n  } // Toggle children on click.\n\n\n  onButtonClick(d) {\n    console.log(\"d\", d); // If childrens are expanded\n\n    if (d.children) {\n      //Collapse them\n      d._children = d.children;\n      d.children = null; // Set descendants expanded property to false\n\n      this.setExpansionFlagToChildren(d, false);\n    } else {\n      // Expand children\n      d.children = d._children;\n      d._children = null; // Set each children as expanded\n\n      d.children.forEach(({\n        data\n      }) => data.expanded = true);\n    }\n\n    if (d.parent) {\n      this.setExpansionFlagToSiblings(d, true);\n    } // Redraw Graph \n\n\n    this.update(d);\n  } // This function changes `expanded` property to descendants\n\n\n  setExpansionFlagToChildren({\n    data,\n    children,\n    _children\n  }, flag) {\n    // Set flag to the current property\n    data.expanded = flag; // Loop over and recursively update expanded children's descendants\n\n    if (children) {\n      children.forEach(d => {\n        this.setExpansionFlagToChildren(d, flag);\n      });\n    } // Loop over and recursively update collapsed children's descendants\n\n\n    if (_children) {\n      _children.forEach(d => {\n        this.setExpansionFlagToChildren(d, flag);\n      });\n    }\n  } // This function changes `expanded` property to descendants\n\n\n  setExpansionFlagToSiblings({\n    data,\n    parent\n  }, flag) {\n    // Set flag to the current property\n    data.expanded = flag; // Loop over and recursively update expanded children's descendants\n\n    if (parent) {\n      parent.children.forEach(d => {\n        if (d.data.nodeId !== data.nodeId) {\n          console.log(\"entrou\");\n          this.setExpansionFlagToChildren(d, flag);\n        }\n      });\n    } // // Loop over and recursively update collapsed children's descendants\n    // if (_children) {\n    //     _children.forEach(d => {\n    //         this.setExpansionFlagToChildren(d, flag)\n    //     })\n    // }\n\n  } // This function can be invoked via chart.setExpanded API, it expands or collapses particular node\n\n\n  setExpanded(id, expandedFlag) {\n    const attrs = this.getChartState(); // Retrieve node by node Id\n\n    const node = attrs.allNodes.filter(({\n      data\n    }) => data.nodeId == id)[0]; // If node exists, set expansion flag\n\n    if (node) node.data.expanded = expandedFlag; // First expand all nodes\n\n    attrs.root.children.forEach(d => this.expand(d)); // Then collapse all nodes\n\n    attrs.root.children.forEach(d => this.collapse(d)); // Then expand only the nodes, which were previously expanded, or have an expand flag set\n\n    attrs.root.children.forEach(d => this.expandSomeNodes(d)); // Redraw graph\n\n    this.update(attrs.root);\n  } // Method which only expands nodes, which have property set \"expanded=true\"\n\n\n  expandSomeNodes(d) {\n    // If node has expanded property set\n    if (d.data.expanded) {\n      // Retrieve node's parent\n      let parent = d.parent; // While we can go up \n\n      while (parent) {\n        // Expand all current parent's children\n        if (parent._children) {\n          parent.children = parent._children;\n        } // Replace current parent holding object\n\n\n        parent = parent.parent;\n      }\n    } // Recursivelly do the same for collapsed nodes\n\n\n    if (d._children) {\n      d._children.forEach(ch => this.expandSomeNodes(ch));\n    } // Recursivelly do the same for expanded nodes \n\n\n    if (d.children) {\n      d.children.forEach(ch => this.expandSomeNodes(ch));\n    }\n  } // This function updates nodes state and redraws graph, usually after data change\n\n\n  updateNodesState() {\n    const attrs = this.getChartState(); // Store new root by converting flat data to hierarchy\n\n    attrs.root = d3.stratify().id(({\n      nodeId\n    }) => nodeId).parentId(({\n      parentNodeId\n    }) => parentNodeId)(attrs.data); // Store positions, where children appear during their enter animation\n\n    attrs.root.x0 = 0;\n    attrs.root.y0 = 0; // Store all nodes in flat format (although, now we can browse parent, see depth e.t.c. )\n\n    attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants(); // Store direct and total descendants count\n\n    attrs.allNodes.forEach(d => {\n      Object.assign(d.data, {\n        directSubordinates: d.children ? d.children.length : 0,\n        totalSubordinates: d.descendants().length - 1\n      });\n    }); // Expand all nodes first\n\n    attrs.root.children.forEach(this.expand); // Then collapse them all\n\n    attrs.root.children.forEach(d => this.collapse(d)); // Then only expand nodes, which have expanded proprty set to true\n\n    attrs.root.children.forEach(ch => this.expandSomeNodes(ch)); // Redraw Graphs\n\n    this.update(attrs.root);\n  } // Function which collapses passed node and it's descendants\n\n\n  collapse(d) {\n    if (d.children) {\n      d._children = d.children;\n\n      d._children.forEach(ch => this.collapse(ch));\n\n      d.children = null;\n    }\n  } // Function which expands passed node and it's descendants \n\n\n  expand(d) {\n    if (d._children) {\n      d.children = d._children;\n      d.children.forEach(ch => this.expand(ch));\n      d._children = null;\n    }\n  } // Zoom handler function\n\n\n  zoomed() {\n    const attrs = this.getChartState();\n    const chart = attrs.chart; // Get d3 event's transform object\n\n    const transform = d3.event.transform; // Store it\n\n    attrs.lastTransform = transform; // Reposition and rescale chart accordingly\n\n    chart.attr('transform', transform); // Apply new styles to the foreign object element\n\n    if (this.isEdge()) {\n      this.restyleForeignObjectElements();\n    }\n  }\n\n}\n\nexport default Chart;","map":{"version":3,"sources":["/Users/samirsilva/org-chart/src/org-chart/tree-chart.js"],"names":["d3","Chart","constructor","attrs","id","Math","floor","random","svgWidth","svgHeight","marginTop","marginBottom","marginRight","marginLeft","container","defaultTextFill","nodeTextFill","defaultFont","backgroundColor","data","depth","duration","strokeWidth","dropShadowId","initialZoom","onNodeClick","d","getChartState","Object","keys","forEach","key","_","string","arguments","length","eval","initializeEnterExitUpdatePattern","selection","prototype","patternify","params","selector","elementTag","tag","selectAll","i","exit","remove","enter","append","merge","attr","getNodeChildrenIds","children","_children","nodeIdsStore","push","nodeId","setZoomFactor","zoomLevel","calc","centerG","centerX","nodeMaxHeight","render","thisObjRef","select","containerRect","node","getBoundingClientRect","width","setDropShadowId","chartTopMargin","chartLeftMargin","chartWidth","chartHeight","nodeMaxWidth","max","height","layouts","treemap","tree","size","nodeSize","behaviors","zoom","on","zoomed","root","stratify","parentId","parentNodeId","x0","y0","allNodes","descendants","assign","directSubordinates","totalSubordinates","collapse","expandSomeNodes","svg","call","style","chart","defs","filterDefs","filter","feMerge","update","window","addNode","obj","updateNodesState","removeNode","nodeChildrenIds","includes","bind","x","y","treeData","nodes","map","imageWidth","imageHeight","imageBorderColor","imageBorderWidth","imageRx","imageCenterTopDistance","imageCenterLeftDistance","borderColor","nodeImage","shadow","rgbaObjToColor","borderWidth","centerTopDistance","centerLeftDistance","cornerShape","toLowerCase","min","links","slice","patternsSelection","patternEnterSelection","patterns","patternImages","url","transition","linkSelection","linkEnter","insert","o","diagonal","linkUpdate","connectorLineWidth","connectorLineColor","dashArray","parent","linkExit","nodesSelection","nodeEnter","event","srcElement","classList","nodeIcon","icon","text","nodeImageGroups","nodeUpdate","fo","restyleForeignObjectElements","nodeButtonGroups","onButtonClick","borderRadius","isEdge","nodeExitTransition","navigator","userAgent","red","green","blue","alpha","s","t","ex","ey","xrvs","yrvs","rdef","rInitial","abs","r","h","w","path","html","template","console","log","setExpansionFlagToChildren","expanded","setExpansionFlagToSiblings","flag","setExpanded","expandedFlag","expand","ch","transform","lastTransform"],"mappings":"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","sourcesContent":["\nimport * as d3 from \"d3\";\n\nclass Chart {\n    constructor() {\n        // Exposed variables\n        const attrs = {\n            id: `ID${Math.floor(Math.random() * 1000000)}`, // Id for event handlings\n            svgWidth: 800,\n            svgHeight: 600,\n            marginTop: 0,\n            marginBottom: 0,\n            marginRight: 0,\n            marginLeft: 0,\n            container: 'body',\n            defaultTextFill: 'white',\n            nodeTextFill: 'white',\n            defaultFont: 'Helvetica',\n            backgroundColor: '#22518e',\n            data: null,\n            depth: 180,\n            duration: 600,\n            strokeWidth: 3,\n            dropShadowId: null,\n            initialZoom: 1,\n            onNodeClick: d => d,\n        };\n  \n        this.getChartState = () => attrs;\n  \n        // Dinamically set getter and setter functions for Chart class\n        Object.keys(attrs).forEach((key) => {\n            //@ts-ignore\n            this[key] = function(_) {\n                var string = `attrs['${key}'] = _`;\n                if (!arguments.length) {\n                    return eval(`attrs['${key}'];`);\n                }\n                eval(string);\n                return this;\n            };\n        });\n  \n  \n        this.initializeEnterExitUpdatePattern();\n    }\n  \n    initializeEnterExitUpdatePattern() {\n        d3.selection.prototype.patternify = function(params) {\n            var container = this;\n            var selector = params.selector;\n            var elementTag = params.tag;\n            var data = params.data || [selector];\n  \n            // Pattern in action\n            var selection = container.selectAll('.' + selector).data(data, (d, i) => {\n                if (typeof d === 'object') {\n                    if (d.id) {\n                        return d.id;\n                    }\n                }\n                return i;\n            });\n            selection.exit().remove();\n            selection = selection.enter().append(elementTag).merge(selection);\n            selection.attr('class', selector);\n            return selection;\n        };\n    }\n  \n    // This method retrieves passed node's children ID's (including node)      \n    getNodeChildrenIds({\n        data,\n        children,\n        _children\n    }, nodeIdsStore) {\n  \n        // Store current node ID\n        nodeIdsStore.push(data.nodeId);\n  \n        // Loop over children and recursively store descendants id (expanded nodes)\n        if (children) {\n            children.forEach(d => {\n                this.getNodeChildrenIds(d, nodeIdsStore)\n            })\n        }\n  \n        // Loop over _children and recursively store descendants id (collapsed nodes)\n        if (_children) {\n            _children.forEach(d => {\n                this.getNodeChildrenIds(d, nodeIdsStore)\n            })\n        }\n  \n        // Return result\n        return nodeIdsStore;\n    }\n  \n    // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale\n    setZoomFactor(zoomLevel) {\n        const attrs = this.getChartState();\n        const calc = attrs.calc;\n  \n        // Store passed zoom level\n        attrs.initialZoom = zoomLevel;\n  \n        // Rescale container element accordingly\n        attrs.centerG.attr('transform', ` translate(${calc.centerX}, ${calc.nodeMaxHeight/2}) scale(${attrs.initialZoom})`)\n    }\n  \n    render() {\n        //InnerFunctions which will update visuals\n  \n        const attrs = this.getChartState();\n        const thisObjRef = this;\n  \n        //Drawing containers\n        const container = d3.select(attrs.container);\n        const containerRect = container.node().getBoundingClientRect();\n        if (containerRect.width > 0) attrs.svgWidth = containerRect.width;\n  \n        //Attach drop shadow id to attrs object\n        this.setDropShadowId(attrs);\n  \n        //Calculated properties\n        const calc = {\n            id: null,\n            chartTopMargin: null,\n            chartLeftMargin: null,\n            chartWidth: null,\n            chartHeight: null\n        };\n        calc.id = `ID${Math.floor(Math.random() * 1000000)}`; // id for event handlings\n        calc.chartLeftMargin = attrs.marginLeft;\n        calc.chartTopMargin = attrs.marginTop;\n        calc.chartWidth = attrs.svgWidth - attrs.marginRight - calc.chartLeftMargin;\n        calc.chartHeight = attrs.svgHeight - attrs.marginBottom - calc.chartTopMargin;\n        attrs.calc = calc;\n  \n        // Get maximum node width and height\n        calc.nodeMaxWidth = d3.max(attrs.data, ({\n            width\n        }) => width);\n        calc.nodeMaxHeight = d3.max(attrs.data, ({\n            height\n        }) => height);\n  \n        // Calculate max node depth (it's needed for layout heights calculation)\n        attrs.depth = calc.nodeMaxHeight + 100;\n        calc.centerX = calc.chartWidth / 2;\n  \n        //********************  LAYOUTS  ***********************\n        const layouts = {\n            treemap: null\n        }\n        attrs.layouts = layouts;\n  \n        // Generate tree layout function\n        layouts.treemap = d3.tree().size([calc.chartWidth, calc.chartHeight])\n            .nodeSize([calc.nodeMaxWidth + 100, calc.nodeMaxHeight + attrs.depth])\n  \n        // ******************* BEHAVIORS . **********************\n        const behaviors = {\n            zoom: null\n        }\n  \n        // Get zooming function \n        behaviors.zoom = d3.zoom().on(\"zoom\", d => this.zoomed(d))\n  \n        //****************** ROOT node work ************************\n  \n        // Convert flat data to hierarchical\n        attrs.root = d3.stratify()\n            .id(({\n                nodeId\n            }) => nodeId)\n            .parentId(({\n                parentNodeId\n            }) => parentNodeId)\n            (attrs.data)\n  \n        // Set child nodes enter appearance positions\n        attrs.root.x0 = 0;\n        attrs.root.y0 = 0;\n  \n        /** Get all nodes as array (with extended parent & children properties set)\n            This way we can access any node's parent directly using node.parent - pretty cool, huh?\n        */\n        attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants()\n  \n        // Assign direct children and total subordinate children's cound\n        attrs.allNodes.forEach(d => {\n            Object.assign(d.data, {\n                directSubordinates: d.children ? d.children.length : 0,\n                totalSubordinates: d.descendants().length - 1\n            })\n        })\n  \n        // Collapse all children at first\n        attrs.root.children.forEach(d => this.collapse(d));\n  \n        // Then expand some nodes, which have `expanded` property set\n        attrs.root.children.forEach(d => this.expandSomeNodes(d));\n  \n        // *************************  DRAWING **************************\n        //Add svg\n        const svg = container\n            .patternify({\n                tag: 'svg',\n                selector: 'svg-chart-container'\n            })\n            .attr('width', \"100%\")\n            .attr('height', \"100vh\")\n            .attr('font-family', attrs.defaultFont)\n            .call(behaviors.zoom)\n            .attr('cursor', 'move')\n            .style('background-color', attrs.backgroundColor);\n        attrs.svg = svg;\n  \n        //Add container g element\n        const chart = svg\n            .patternify({\n                tag: 'g',\n                selector: 'chart'\n            })\n            .attr('transform', `translate(${calc.chartLeftMargin},${calc.chartTopMargin})`);\n  \n        // Add one more container g element, for better positioning controls\n        attrs.centerG = chart.patternify({\n                tag: 'g',\n                selector: 'center-group'\n            })\n            .attr('transform', `translate(${calc.centerX},${calc.nodeMaxHeight/2}) scale(${attrs.initialZoom})`);\n  \n        attrs.chart = chart;\n  \n        // ************************** ROUNDED AND SHADOW IMAGE  WORK USING SVG FILTERS **********************\n  \n        //Adding defs element for rounded image\n        attrs.defs = svg.patternify({\n            tag: 'defs',\n            selector: 'image-defs'\n        });\n  \n        // Adding defs element for image's shadow\n        const filterDefs = svg.patternify({\n            tag: 'defs',\n            selector: 'filter-defs'\n        });\n  \n        // Adding shadow element - (play with svg filter here - https://bit.ly/2HwnfyL)\n        const filter = filterDefs.patternify({\n                tag: 'filter',\n                selector: 'shadow-filter-element'\n            })\n            .attr('id', attrs.dropShadowId)\n            .attr('y', `${-50}%`)\n            .attr('x', `${-50}%`)\n            .attr('height', `${200}%`)\n            .attr('width', `${200}%`);\n  \n        // Add gaussian blur element for shadows - we can control shadow length with this\n        filter.patternify({\n                tag: 'feGaussianBlur',\n                selector: 'feGaussianBlur-element'\n            })\n            .attr('in', 'SourceAlpha')\n            .attr('stdDeviation', 3.1)\n            .attr('result', 'blur');\n  \n        // Add fe-offset element for shadows -  we can control shadow positions with it\n        filter.patternify({\n                tag: 'feOffset',\n                selector: 'feOffset-element'\n            })\n            .attr('in', 'blur')\n            .attr('result', 'offsetBlur')\n            .attr(\"dx\", 4.28)\n            .attr(\"dy\", 4.48)\n            .attr(\"x\", 8)\n            .attr(\"y\", 8)\n  \n        // Add fe-flood element for shadows - we can control shadow color and opacity with this element\n        filter.patternify({\n                tag: 'feFlood',\n                selector: 'feFlood-element'\n            })\n            .attr(\"in\", \"offsetBlur\")\n            .attr(\"flood-color\", 'black')\n            .attr(\"flood-opacity\", 0.3)\n            .attr(\"result\", \"offsetColor\");\n  \n        // Add feComposite element for shadows\n        filter.patternify({\n                tag: 'feComposite',\n                selector: 'feComposite-element'\n            })\n            .attr(\"in\", \"offsetColor\")\n            .attr(\"in2\", \"offsetBlur\")\n            .attr(\"operator\", \"in\")\n            .attr(\"result\", \"offsetBlur\");\n  \n        // Add feMerge element for shadows\n        const feMerge = filter.patternify({\n            tag: 'feMerge',\n            selector: 'feMerge-element'\n        });\n  \n        // Add feMergeNode element for shadows\n        feMerge.patternify({\n                tag: 'feMergeNode',\n                selector: 'feMergeNode-blur'\n            })\n            .attr('in', 'offsetBlur')\n  \n        // Add another feMergeNode element for shadows\n        feMerge.patternify({\n                tag: 'feMergeNode',\n                selector: 'feMergeNode-graphic'\n            })\n            .attr('in', 'SourceGraphic')\n  \n        // Display tree contenrs\n        this.update(attrs.root)\n  \n  \n  \n        //#########################################  UTIL FUNCS ##################################\n        // This function restyles foreign object elements ()\n  \n  \n  \n  \n        d3.select(window).on(`resize.${attrs.id}`, () => {\n            const containerRect = container.node().getBoundingClientRect();\n            //  if (containerRect.width > 0) attrs.svgWidth = containerRect.width;\n            //\tmain();\n        });\n  \n  \n        return this;\n    }\n  \n    // This function sets drop shadow ID to the passed object\n    setDropShadowId(d) {\n  \n        // If it's already set, then return \n        if (d.dropShadowId) return;\n  \n        // Generate drop shadow ID\n        let id = `${d.id}-drop-shadow`;\n  \n        // // If DOM object is available, then use UID method to generated shadow id\n        // //@ts-ignore\n        // if (typeof DOM != 'undefined') {\n        //     //@ts-ignore\n        //     id = DOM.uid(d.id).id;\n        // }\n  \n        // Extend passed object with drop shadow ID\n        Object.assign(d, {\n            dropShadowId: id\n        })\n    }\n  \n  \n    // This function can be invoked via chart.addNode API, and it adds node in tree at runtime\n    addNode(obj) {\n        const attrs = this.getChartState();\n        attrs.data.push(obj);\n  \n        // Update state of nodes and redraw graph\n        this.updateNodesState();\n        return this;\n    }\n  \n    // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime\n    removeNode(nodeId) {\n        const attrs = this.getChartState();\n        const node = attrs.allNodes.filter(({\n            data\n        }) => data.nodeId == nodeId)[0];\n  \n  \n        // Remove all node childs\n        if (node) {\n            // Retrieve all children nodes ids (including current node itself)\n            const nodeChildrenIds = this.getNodeChildrenIds(node, []);\n  \n            // Filter out retrieved nodes and reassign data\n            attrs.data = attrs.data.filter(d => !nodeChildrenIds.includes(d.nodeId))\n  \n            const updateNodesState = this.updateNodesState.bind(this);\n            // Update state of nodes and redraw graph\n            updateNodesState();\n        }\n    }\n  \n    // This function basically redraws visible graph, based on nodes state\n    update({\n        x0,\n        y0,\n        x,\n        y\n    }) {\n  \n        const attrs = this.getChartState();\n        const calc = attrs.calc;\n  \n        //  Assigns the x and y position for the nodes\n        const treeData = attrs.layouts.treemap(attrs.root);\n  \n        // Get tree nodes and links and attach some properties \n        const nodes = treeData.descendants()\n            .map(d => {\n                // If at least one property is already set, then we don't want to reset other properties\n                if (d.width) return d;\n  \n                // Declare properties with deffault values\n                let imageWidth = 100;\n                let imageHeight = 100;\n                let imageBorderColor = 'steelblue';\n                let imageBorderWidth = 0;\n                let imageRx = 0;\n                let imageCenterTopDistance = 0;\n                let imageCenterLeftDistance = 0;\n                let borderColor = 'steelblue';\n                let backgroundColor = 'steelblue';\n                let width = d.data.width;\n                let height = d.data.height;\n                let dropShadowId = `none`;\n  \n                // Override default values based on data\n                if (d.data.nodeImage && d.data.nodeImage.shadow) {\n                    dropShadowId = `url(#${attrs.dropShadowId})`\n                }\n                if (d.data.nodeImage && d.data.nodeImage.width) {\n                    imageWidth = d.data.nodeImage.width\n                };\n                if (d.data.nodeImage && d.data.nodeImage.height) {\n                    imageHeight = d.data.nodeImage.height\n                };\n                if (d.data.nodeImage && d.data.nodeImage.borderColor) {\n                    imageBorderColor = this.rgbaObjToColor(d.data.nodeImage.borderColor)\n                };\n                if (d.data.nodeImage && d.data.nodeImage.borderWidth) {\n                    imageBorderWidth = d.data.nodeImage.borderWidth\n                };\n                if (d.data.nodeImage && d.data.nodeImage.centerTopDistance) {\n                    imageCenterTopDistance = d.data.nodeImage.centerTopDistance\n                };\n                if (d.data.nodeImage && d.data.nodeImage.centerLeftDistance) {\n                    imageCenterLeftDistance = d.data.nodeImage.centerLeftDistance\n                };\n                if (d.data.borderColor) {\n                    borderColor = this.rgbaObjToColor(d.data.borderColor);\n                }\n                if (d.data.backgroundColor) {\n                    backgroundColor = this.rgbaObjToColor(d.data.backgroundColor);\n                }\n                if (d.data.nodeImage &&\n                    d.data.nodeImage.cornerShape.toLowerCase() == \"circle\") {\n                    imageRx = Math.max(imageWidth, imageHeight);\n                }\n                if (d.data.nodeImage &&\n                    d.data.nodeImage.cornerShape.toLowerCase() == \"rounded\") {\n                    imageRx = Math.min(imageWidth, imageHeight) / 6;\n                }\n  \n                // Extend node object with calculated properties\n                return Object.assign(d, {\n                    imageWidth,\n                    imageHeight,\n                    imageBorderColor,\n                    imageBorderWidth,\n                    borderColor,\n                    backgroundColor,\n                    imageRx,\n                    width,\n                    height,\n                    imageCenterTopDistance,\n                    imageCenterLeftDistance,\n                    dropShadowId\n                });\n            });\n  \n        // Get all links\n        const links = treeData.descendants().slice(1);\n  \n        // Set constant depth for each nodes\n        nodes.forEach(d => d.y = d.depth * attrs.depth);\n  \n        // ------------------- FILTERS ---------------------\n  \n        // Add patterns for each node (it's needed for rounded image implementation)\n        const patternsSelection = attrs.defs.selectAll('.pattern')\n            .data(nodes, ({\n                id\n            }) => id);\n  \n        // Define patterns enter selection\n        const patternEnterSelection = patternsSelection.enter().append('pattern')\n  \n        // Patters update selection\n        const patterns = patternEnterSelection\n            .merge(patternsSelection)\n            .attr('class', 'pattern')\n            .attr('height', 1)\n            .attr('width', 1)\n            .attr('id', ({\n                id\n            }) => id)\n  \n        // Add images to patterns\n        const patternImages = patterns.patternify({\n                tag: 'image',\n                selector: 'pattern-image',\n                data: d => [d]\n            })\n            .attr('x', 0)\n            .attr('y', 0)\n            .attr('height', ({\n                imageWidth\n            }) => imageWidth)\n            .attr('width', ({\n                imageHeight\n            }) => imageHeight)\n            .attr('xlink:href', ({\n                data\n            }) => data.nodeImage.url)\n            .attr('viewbox', ({\n                imageWidth,\n                imageHeight\n            }) => `0 0 ${imageWidth*2} ${imageHeight}`)\n            .attr('preserveAspectRatio', 'xMidYMin slice')\n  \n        // Remove patterns exit selection after animation\n        patternsSelection.exit().transition().duration(attrs.duration).remove();\n  \n        // --------------------------  LINKS ----------------------\n        // Get links selection\n        const linkSelection = attrs.centerG.selectAll('path.link')\n            .data(links, ({\n                id\n            }) => id);\n  \n        // Enter any new links at the parent's previous position.\n        const linkEnter = linkSelection.enter()\n            .insert('path', \"g\")\n            .attr(\"class\", \"link\")\n            .attr('d', d => {\n                const o = {\n                    x: x0,\n                    y: y0\n                };\n                return this.diagonal(o, o)\n            });\n  \n        // Get links update selection\n        const linkUpdate = linkEnter.merge(linkSelection);\n  \n        // Styling links\n        linkUpdate\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke-width\", ({\n                data\n            }) => data.connectorLineWidth || 2)\n            .attr('stroke', ({\n                data\n            }) => {\n                if (data.connectorLineColor) {\n                    return this.rgbaObjToColor(data.connectorLineColor);\n                }\n                return 'green';\n            })\n            .attr('stroke-dasharray', ({\n                data\n            }) => {\n                if (data.dashArray) {\n                    return data.dashArray;\n                }\n                return '';\n            })\n  \n        // Transition back to the parent element position\n        linkUpdate.transition()\n            .duration(attrs.duration)\n            .attr('d', d => this.diagonal(d, d.parent));\n  \n        // Remove any  links which is exiting after animation\n        const linkExit = linkSelection.exit().transition()\n            .duration(attrs.duration)\n            .attr('d', d => {\n                const o = {\n                    x: x,\n                    y: y\n                };\n                return this.diagonal(o, o)\n            })\n            .remove();\n  \n        // --------------------------  NODES ----------------------\n        // Get nodes selection\n        const nodesSelection = attrs.centerG.selectAll('g.node')\n            .data(nodes, ({\n                id\n            }) => id)\n  \n        // Enter any new nodes at the parent's previous position.\n        const nodeEnter = nodesSelection.enter().append('g')\n            .attr('class', 'node')\n            .attr(\"transform\", d => `translate(${x0},${y0})`)\n            .attr('cursor', 'pointer')\n            .on('click', ({\n                data\n            }) => {\n                if ([...d3.event.srcElement.classList].includes('node-button-circle')) {\n                    return;\n                }\n                attrs.onNodeClick(data.nodeId);\n            });\n  \n        // Add background rectangle for the nodes \n        nodeEnter\n            .patternify({\n                tag: 'rect',\n                selector: 'node-rect',\n                data: d => [d]\n            })\n            .style(\"fill\", ({\n                _children\n            }) => _children ? \"lightsteelblue\" : \"#fff\")\n  \n  \n  \n        // Add node icon image inside node\n        nodeEnter\n            .patternify({\n                tag: 'image',\n                selector: 'node-icon-image',\n                data: d => [d]\n            })\n            .attr('width', ({\n                data\n            }) => data.nodeIcon.size)\n            .attr('height', ({\n                data\n            }) => data.nodeIcon.size)\n            .attr(\"xlink:href\", ({\n                data\n            }) => data.nodeIcon.icon)\n            .attr('x', ({\n                width\n            }) => -width / 2 + 5)\n            .attr('y', ({\n                height,\n                data\n            }) => height / 2 - data.nodeIcon.size - 5)\n  \n        // Add total descendants text\n        nodeEnter\n            .patternify({\n                tag: 'text',\n                selector: 'node-icon-text-total',\n                data: d => [d]\n            })\n            .text('test')\n            .attr('x', ({\n                width\n            }) => -width / 2 + 7)\n            .attr('y', ({\n                height,\n                data\n            }) => height / 2 - data.nodeIcon.size - 5)\n            .text(({\n                data\n            }) => `${data.totalSubordinates} Subordinates`)\n            .attr('fill', attrs.nodeTextFill)\n            .attr('font-weight', 'bold')\n  \n        // Add direct descendants text\n        nodeEnter\n            .patternify({\n                tag: 'text',\n                selector: 'node-icon-text-direct',\n                data: d => [d]\n            })\n            .text('test')\n            .attr('x', ({\n                width,\n                data\n            }) => -width / 2 + 10 + data.nodeIcon.size)\n            .attr('y', ({\n                height\n            }) => height / 2 - 10)\n            .text(({\n                data\n            }) => `${data.directSubordinates} Direct `)\n            .attr('fill', attrs.nodeTextFill)\n            .attr('font-weight', 'bold')\n  \n  \n        // Defined node images wrapper group\n        const nodeImageGroups = nodeEnter.patternify({\n            tag: 'g',\n            selector: 'node-image-group',\n            data: d => [d]\n        })\n  \n        // Add background rectangle for node image\n        nodeImageGroups\n            .patternify({\n                tag: 'rect',\n                selector: 'node-image-rect',\n                data: d => [d]\n            })\n  \n  \n  \n        // Node update styles\n        const nodeUpdate = nodeEnter.merge(nodesSelection)\n            .style('font', '12px sans-serif');\n  \n  \n  \n        // Add foreignObject element inside rectangle\n        const fo = nodeUpdate\n            .patternify({\n                tag: 'foreignObject',\n                selector: 'node-foreign-object',\n                data: d => [d]\n            })\n  \n  \n        // Add foreign object \n        fo.patternify({\n            tag: 'xhtml:div',\n            selector: 'node-foreign-object-div',\n            data: d => [d]\n        })\n  \n        this.restyleForeignObjectElements();\n  \n  \n  \n        // Add Node button circle's group (expand-collapse button)\n        const nodeButtonGroups = nodeEnter\n            .patternify({\n                tag: 'g',\n                selector: 'node-button-g',\n                data: d => [d]\n            })\n            .on('click', d => this.onButtonClick(d))\n  \n        // Add expand collapse button circle \n        nodeButtonGroups\n            .patternify({\n                tag: 'circle',\n                selector: 'node-button-circle',\n                data: d => [d]\n            })\n  \n        // Add button text \n        nodeButtonGroups\n            .patternify({\n                tag: 'text',\n                selector: 'node-button-text',\n                data: d => [d]\n            })\n            .attr('pointer-events', 'none')\n  \n        // Transition to the proper position for the node\n        nodeUpdate.transition()\n            .attr('opacity', 0)\n            .duration(attrs.duration)\n            .attr(\"transform\", ({\n                x,\n                y\n            }) => `translate(${x},${y})`)\n            .attr('opacity', 1)\n  \n        // Move images to desired positions\n        nodeUpdate.selectAll('.node-image-group')\n            .attr('transform', ({\n                imageWidth,\n                width,\n                imageHeight,\n                height\n            }) => {\n                let x = -imageWidth / 2 - width / 2;\n                let y = -imageHeight / 2 - height / 2;\n                return `translate(${x},${y})`\n            })\n  \n        // Style node image rectangles\n        nodeUpdate.select('.node-image-rect')\n            .attr('fill', ({\n                id\n            }) => `url(#${id})`)\n            .attr('width', ({\n                imageWidth\n            }) => imageWidth)\n            .attr('height', ({\n                imageHeight\n            }) => imageHeight)\n            .attr('stroke', ({\n                imageBorderColor\n            }) => imageBorderColor)\n            .attr('stroke-width', ({\n                imageBorderWidth\n            }) => imageBorderWidth)\n            .attr('rx', ({\n                imageRx\n            }) => imageRx)\n            .attr('y', ({\n                imageCenterTopDistance\n            }) => imageCenterTopDistance)\n            .attr('x', ({\n                imageCenterLeftDistance\n            }) => imageCenterLeftDistance)\n            .attr('filter', ({\n                dropShadowId\n            }) => dropShadowId)\n  \n        // Style node rectangles\n        nodeUpdate.select('.node-rect')\n            .attr('width', ({\n                data\n            }) => data.width)\n            .attr('height', ({\n                data\n            }) => data.height)\n            .attr('x', ({\n                data\n            }) => -data.width / 2)\n            .attr('y', ({\n                data\n            }) => -data.height / 2)\n            .attr('rx', ({\n                data\n            }) => data.borderRadius || 0)\n            .attr('stroke-width', ({\n                data\n            }) => data.borderWidth || attrs.strokeWidth)\n            .attr('cursor', 'pointer')\n            .attr('stroke', ({\n                borderColor\n            }) => borderColor)\n            .style(\"fill\", ({\n                backgroundColor\n            }) => backgroundColor)\n  \n        // Move node button group to the desired position\n        nodeUpdate.select('.node-button-g')\n            .attr('transform', ({\n                data\n            }) => `translate(0,${data.height/2})`)\n            .attr('opacity', ({\n                children,\n                _children\n            }) => {\n                if (children || _children) {\n                    return 1;\n                }\n                return 0;\n            })\n  \n        // Restyle node button circle\n        nodeUpdate.select('.node-button-circle')\n            .attr('r', 20)\n            .attr('stroke-width', ({\n                data\n            }) => data.borderWidth || attrs.strokeWidth)\n            .attr('fill', attrs.backgroundColor)\n            .attr('stroke', ({\n                borderColor\n            }) => borderColor)\n  \n        // Restyle button texts\n        nodeUpdate.select('.node-button-text')\n            .attr('text-anchor', 'middle')\n            .attr('alignment-baseline', 'middle')\n            .attr('fill', attrs.defaultTextFill)\n            .attr('font-size', ({\n                children\n            }) => {\n                if (children) return 40;\n                return 30;\n            })\n            .text(({\n                children\n            }) => {\n                if (children) return '-';\n                return '+';\n            })\n            .attr('y', this.isEdge() ? 10 : 0)\n  \n        // Remove any exiting nodes after transition\n        const nodeExitTransition = nodesSelection.exit()\n            .attr('opacity', 1)\n            .transition()\n            .duration(attrs.duration)\n            .attr(\"transform\", d => `translate(${x},${y})`)\n            .on('end', function() {\n                d3.select(this).remove();\n            })\n            .attr('opacity', 0);\n  \n        // On exit reduce the node rects size to 0\n        nodeExitTransition.selectAll('.node-rect')\n            .attr('width', 10)\n            .attr('height', 10)\n            .attr('x', 0)\n            .attr('y', 0);\n  \n        // On exit reduce the node image rects size to 0\n        nodeExitTransition.selectAll('.node-image-rect')\n            .attr('width', 10)\n            .attr('height', 10)\n            .attr('x', ({\n                width\n            }) => width / 2)\n            .attr('y', ({\n                height\n            }) => height / 2)\n  \n        // Store the old positions for transition.\n        nodes.forEach(d => {\n            d.x0 = d.x;\n            d.y0 = d.y;\n        });\n    }\n  \n    // This function detects whether current browser is edge\n    isEdge() {\n        return window.navigator.userAgent.includes(\"Edge\");\n    }\n  \n    /* Function converts rgba objects to rgba color string \n      {red:110,green:150,blue:255,alpha:1}  => rgba(110,150,255,1)\n    */\n    rgbaObjToColor({\n        red,\n        green,\n        blue,\n        alpha\n    }) {\n        return `rgba(${red},${green},${blue},${alpha})`;\n    }\n  \n    // Generate custom diagonal - play with it here - https://to.ly/1zhTK\n    diagonal(s, t) {\n  \n        // Calculate some variables based on source and target (s,t) coordinates\n        const x = s.x;\n        const y = s.y;\n        const ex = t.x;\n        const ey = t.y;\n        let xrvs = ex - x < 0 ? -1 : 1;\n        let yrvs = ey - y < 0 ? -1 : 1;\n        let rdef = 35;\n        let rInitial = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;\n        let r = Math.abs(ey - y) / 2 < rInitial ? Math.abs(ey - y) / 2 : rInitial;\n        let h = Math.abs(ey - y) / 2 - r;\n        let w = Math.abs(ex - x) - r * 2;\n  \n        // Build the path\n        const path = `\n               M ${x} ${y}\n               L ${x} ${y+h*yrvs}\n               C  ${x} ${y+h*yrvs+r*yrvs} ${x} ${y+h*yrvs+r*yrvs} ${x+r*xrvs} ${y+h*yrvs+r*yrvs}\n               L ${x+w*xrvs+r*xrvs} ${y+h*yrvs+r*yrvs}\n               C ${ex}  ${y+h*yrvs+r*yrvs} ${ex}  ${y+h*yrvs+r*yrvs} ${ex} ${ey-h*yrvs}\n               L ${ex} ${ey}\n             `\n        // Return result\n        return path;\n    }\n  \n    restyleForeignObjectElements() {\n        const attrs = this.getChartState();\n  \n        attrs.svg.selectAll('.node-foreign-object')\n            .attr('width', ({\n                width\n            }) => width)\n            .attr('height', ({\n                height\n            }) => height)\n            .attr('x', ({\n                width\n            }) => -width / 2)\n            .attr('y', ({\n                height\n            }) => -height / 2)\n        attrs.svg.selectAll('.node-foreign-object-div')\n            .style('width', ({\n                width\n            }) => `${width}px`)\n            .style('height', ({\n                height\n            }) => `${height}px`)\n            .style('color', 'white')\n            .html(({\n                data\n            }) => data.template)\n    }\n  \n    // Toggle children on click.\n    onButtonClick(d) {\n        console.log(\"d\", d);\n        // If childrens are expanded\n        if (d.children) {\n  \n            //Collapse them\n            d._children = d.children;\n            d.children = null;\n  \n            // Set descendants expanded property to false\n            this.setExpansionFlagToChildren(d, false);\n        } else {\n  \n            // Expand children\n            d.children = d._children;\n            d._children = null;\n  \n            // Set each children as expanded\n            d.children.forEach(({\n                data\n            }) => data.expanded = true)\n        }\n\n        if(d.parent){\n            this.setExpansionFlagToSiblings(d, true);\n\n        }\n  \n        // Redraw Graph \n        this.update(d);\n    }\n  \n    // This function changes `expanded` property to descendants\n    setExpansionFlagToChildren({\n        data,\n        children,\n        _children\n    }, flag) {\n  \n        // Set flag to the current property\n        data.expanded = flag;\n  \n        // Loop over and recursively update expanded children's descendants\n        if (children) {\n            children.forEach(d => {\n                this.setExpansionFlagToChildren(d, flag)\n            })\n        }\n  \n        // Loop over and recursively update collapsed children's descendants\n        if (_children) {\n            _children.forEach(d => {\n                this.setExpansionFlagToChildren(d, flag)\n            })\n        }\n    }\n\n     // This function changes `expanded` property to descendants\n     setExpansionFlagToSiblings({\n         data,\n         parent\n    }, flag) {\n  \n        // Set flag to the current property\n        data.expanded = flag;\n  \n        // Loop over and recursively update expanded children's descendants\n        if (parent) {\n            parent.children.forEach(d => {\n                    if(d.data.nodeId !== data.nodeId) {\n                        console.log(\"entrou\")\n                        this.setExpansionFlagToChildren(d, flag)\n                    }\n            })\n        }\n  \n        // // Loop over and recursively update collapsed children's descendants\n        // if (_children) {\n        //     _children.forEach(d => {\n        //         this.setExpansionFlagToChildren(d, flag)\n        //     })\n        // }\n    }\n  \n    // This function can be invoked via chart.setExpanded API, it expands or collapses particular node\n    setExpanded(id, expandedFlag) {\n        const attrs = this.getChartState();\n        // Retrieve node by node Id\n        const node = attrs.allNodes.filter(({\n            data\n        }) => data.nodeId == id)[0]\n  \n        // If node exists, set expansion flag\n        if (node) node.data.expanded = expandedFlag;\n  \n        // First expand all nodes\n        attrs.root.children.forEach(d => this.expand(d));\n  \n        // Then collapse all nodes\n        attrs.root.children.forEach(d => this.collapse(d));\n  \n        // Then expand only the nodes, which were previously expanded, or have an expand flag set\n        attrs.root.children.forEach(d => this.expandSomeNodes(d));\n  \n        // Redraw graph\n        this.update(attrs.root);\n    }\n  \n    // Method which only expands nodes, which have property set \"expanded=true\"\n    expandSomeNodes(d) {\n  \n        // If node has expanded property set\n        if (d.data.expanded) {\n  \n            // Retrieve node's parent\n            let parent = d.parent;\n  \n            // While we can go up \n            while (parent) {\n  \n                // Expand all current parent's children\n                if (parent._children) {\n                    parent.children = parent._children;\n                }\n  \n                // Replace current parent holding object\n                parent = parent.parent;\n            }\n        }\n  \n        // Recursivelly do the same for collapsed nodes\n        if (d._children) {\n            d._children.forEach(ch => this.expandSomeNodes(ch));\n        }\n  \n        // Recursivelly do the same for expanded nodes \n        if (d.children) {\n            d.children.forEach(ch => this.expandSomeNodes(ch));\n        }\n    }\n  \n  \n    // This function updates nodes state and redraws graph, usually after data change\n    updateNodesState() {\n        const attrs = this.getChartState();\n        // Store new root by converting flat data to hierarchy\n        attrs.root = d3.stratify()\n            .id(({\n                nodeId\n            }) => nodeId)\n            .parentId(({\n                parentNodeId\n            }) => parentNodeId)\n            (attrs.data)\n  \n        // Store positions, where children appear during their enter animation\n        attrs.root.x0 = 0;\n        attrs.root.y0 = 0;\n  \n        // Store all nodes in flat format (although, now we can browse parent, see depth e.t.c. )\n        attrs.allNodes = attrs.layouts.treemap(attrs.root).descendants()\n  \n        // Store direct and total descendants count\n        attrs.allNodes.forEach(d => {\n            Object.assign(d.data, {\n                directSubordinates: d.children ? d.children.length : 0,\n                totalSubordinates: d.descendants().length - 1\n            })\n        })\n  \n        // Expand all nodes first\n        attrs.root.children.forEach(this.expand);\n  \n        // Then collapse them all\n        attrs.root.children.forEach(d => this.collapse(d));\n  \n        // Then only expand nodes, which have expanded proprty set to true\n        attrs.root.children.forEach(ch => this.expandSomeNodes(ch));\n  \n        // Redraw Graphs\n        this.update(attrs.root)\n    }\n  \n  \n    // Function which collapses passed node and it's descendants\n    collapse(d) {\n        if (d.children) {\n            d._children = d.children;\n            d._children.forEach(ch => this.collapse(ch));\n            d.children = null;\n        }\n    }\n  \n    // Function which expands passed node and it's descendants \n    expand(d) {\n        if (d._children) {\n            d.children = d._children;\n            d.children.forEach(ch => this.expand(ch));\n            d._children = null;\n        }\n    }\n  \n    // Zoom handler function\n    zoomed() {\n        const attrs = this.getChartState();\n        const chart = attrs.chart;\n  \n        // Get d3 event's transform object\n        const transform = d3.event.transform;\n  \n        // Store it\n        attrs.lastTransform = transform;\n  \n        // Reposition and rescale chart accordingly\n        chart.attr('transform', transform);\n  \n        // Apply new styles to the foreign object element\n        if (this.isEdge()) {\n            this.restyleForeignObjectElements();\n        }\n  \n    }\n  \n  }\n  \n  export default Chart;"]},"metadata":{},"sourceType":"module"}